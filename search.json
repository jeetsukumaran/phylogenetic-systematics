[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learning (just enough) Julia for scientific informatics and reasoning",
    "section": "",
    "text": "#\n\n\n\nTitle\n\n\n\n\n\n\n\n\n \n\n\n \n\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "content/articles/basics-of-figures.html",
    "href": "content/articles/basics-of-figures.html",
    "title": "First steps in visualization",
    "section": "",
    "text": "Creating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ.\n\n\n\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure()\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the axes\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\nscatter!(ax, x_vals, y_vals)\n\n# We can save the figure to file\n# savefig(figure, \"scatter1.pdf\")\n\n# Or just display it in-situ\nfigure"
  },
  {
    "objectID": "content/articles/basics-of-figures.html#synopsis",
    "href": "content/articles/basics-of-figures.html#synopsis",
    "title": "First steps in visualization: figures and axes",
    "section": "",
    "text": "Create a Figure to contain the plot Axis object(s).\nCreate the Axis object onto which you will do the plotting, and assign it a “cell” in the Figure.\nPass the Axis object to various plotting functions.\n\n\n\n\n\n\n\nTipFigure, Axis, plot!\n\n\n\n\nusing GLMakie\nfig = Figure()\nax = Axis(\n    fig[1, 1],      # Assign axis to Figure position (1, 1)\n    aspect = DataAspect(),          \n    limits = ( \n        (-5, 5),    # x-axis range, from -5 to 5\n        (-5, 5),    # y-axis range, from -5 to 5\n    ),   \n    xlabel = \"x\",\n    ylabel = \"y\",\n)\n\n# A 100 uniform random variates in range \n# xs = rand(100) \nxs = rand(100) .* 10 .- 5 # A hundred random floating point values between -5 and 5\nys = rand(100) .* 10 .- 5 # A hundred random floating point values between -5 and 5\n\nscatter!(ax, xs, ys)\n\nScatter{Tuple{Vector{Point{2, Float64}}}}"
  },
  {
    "objectID": "content/articles/basics-of-figures.html#every-plot-begins-with-a-figure",
    "href": "content/articles/basics-of-figures.html#every-plot-begins-with-a-figure",
    "title": "First steps in visualization",
    "section": "2 Every plot begins with a Figure",
    "text": "2 Every plot begins with a Figure\nfig = Figure()\nA Figure is the top-level container and silo for graphical elements. Every visual element in Makie belongs to exactly one Figure, either directly or indirectly through the layout.\nA location in the Figure layout is referenced as if it were an \\(x-\\) and \\(y-\\) grid, e.g., fig[1, 1] for the lower-left cell and fig[3, 3] for the upper-right. Cells, and thus the overall grid shape and size, are created as they are called: fig[1,1] will create a single, centrally-located plot, until it is joined by fig[1,4]."
  },
  {
    "objectID": "content/articles/basics-of-figures.html#add-the-axis-object",
    "href": "content/articles/basics-of-figures.html#add-the-axis-object",
    "title": "First steps in visualization",
    "section": "3 Add the Axis object",
    "text": "3 Add the Axis object\nGraphics are typically drawn onto Axis objects, which are allocated slots in Figure containers.\nfig = Figure()\nax = Axis(fig[1,1]; \n        aspect = DataAspect(),          # Keyword arguments customize appearance\n        limits = ( (-5, 5), (-5, 5) )   # \n    )"
  },
  {
    "objectID": "content/articles/basics-of-figures.html#then-plot-away",
    "href": "content/articles/basics-of-figures.html#then-plot-away",
    "title": "First steps in visualization",
    "section": "4 Then plot away",
    "text": "4 Then plot away\nfig = Figure()\nax = Axis(fig[1,1])\nscatter(ax, 1:10, 1:10)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/articles/basics-of-random-number-generation.html",
    "href": "content/articles/basics-of-random-number-generation.html",
    "title": "Random number generation and management",
    "section": "",
    "text": "Key concept: A pseudo-random number generator deterministically generates a sequence of numbers that are distributed randomly.\nA computer algorithm cannot generate a truly random result. Computer algorithms are deterministic. However, a computer algorithm generate a sequence of numbers based on a series of deterministic calculations that behave like a sequence of random numbers would. These algorithms are known as Pseudo-random number generators (PRNG). Pseuodo-random number generators are deterministic, and, being deterministic, their results—the sequence of random numbers they generate—are predictable.\nA computer program (or algorithm) is a deterministic machine. For some given input, it produces some particular output, based on the its programming. It cannot produce a truly random value in the sense of being , as, for any particular input, an algorithm will produce the same predictable output. For many applications, however, what is needed are not so much values that are absolutely random, but rather a series of numbers that are random with respect to each other, at least up to some or values that can be generated one after another that do not have periodicities, patterns, orders, or “structure” in the sequence, at least for particular scale or size of number set. (For other applications, where true unpredictable as well as non-autocorrelated randomness is strictly needed, computers rely on hardware incorporating some physical source randomness, such as radioactive decay or the wax blobs in lava lamps.)\nA pseudo-random number generator is computer algorithm that can produce a series of values that behave like a random sequence with no observable periodicity or pattern, stastistically or otherwise, for a some very long run of numbers. ( The number of random numbers a particular PRNG can generate before repeating is known as its periodicity. All PRNG’s have periodicities, i.e. will eventually begin repeating the sequence, but good PRNG’s, and the ones we will be using, have HUGE periodicities (\\(2^128\\), to be exact). All PRNG’s have periodicities because of the reality of being needed to be represented on computer with a finite number of bits. The number of bits we use to represent the random numbers (or, the internal state that the PRNG tracks and from which it generates the random numbers) sets the limit to the largest number that can generated. This also sets the limit to the number of numbers that can be generated, This means that at some point or another, the update of one iteration will result in a input value for the next iteration that has been used before in the sequence, resulting in the sequence repeating from that point. A 32-bit PRNG might repeat after \\(2^32\\) numbers, while cryptographic applications (and many modern computing platforms, including Julia) use 128-bit keys, resulting in periodicities of \\(2^128\\). )\nThe sequence of numbers that are generated by PRNG are “random” in most ways, including in terms of quantifying its randomness such as its entropy or fitting a uniform probility distribution better than any other, except for one: predictability of the sequence itself. In turns out, however, that, for most applications, including critical cryptographic ones, predictability of the sequence does not matter. What matters is that there is no ordering, patterns, auto-correlations or cross-correlations, or any sort of structure in the numbers, and that the frequency distribution of values follows that of a uniform probability distribution: every possible value is equally probable to occur at every step And this a PRNG can deliver, given usage that does not exceed their periodicity. (In fact, while the entire sequence of numbers generated by a PRNG is predictable, given the algorithm and initial seed, from one number the next (or for that matter, the previous), is entirely unpredictable without knowing the transition or PRNG function. )\nGiven an initial starting or “seed” value, a PRNG algorithm will compute and return a value, and then use this value as the input value for the next random value generated, thus forming chain of inputs and outputs In more complex algorithms, a separate internal state of a set values is computed from the input value, and a separate function is used to calculate the random number from this internal state. It is this internal state that is passed as input to next step rather than the random number itself. In this way, with each output forming the input for the next step, a sequence of numbers are deterministically generated from the initial seed. The entire sequence itself is deterministically generated from the (deterministic) output of one calculation forming the input the to the nex, starting from the initial seed value. As such, any particular seed value given to the algorithm, e.g., 108 or 99, will always return the exact same sequence of numbers. While not random or unpredictable, and, in fact, quite the opposite—deterministic and predictable—the entire sequence is random in that there is no autocorrelation, patterns, or periodicity in the numbers that might lead to artifactual structure in results that rely in it.\nThis predictability of number sequence from a pseudo-random number generator is not really a practical limitation, and, in fact, has some important roles in software engineering as well as scientific computing. It can be useful, sometimes critically so, in software development: the key to solving a bug is to be able to reliably replicate it, and the predictably of a pseudo-random number sequence allows for debugging of programs that rely on randomness including a lot of scientific research software (e.g. Bayesian Markov chain Monte Carlo inference programs). It can also be very useful in scientific research: many times, it is sufficient to note the random seed used for a particular suite of simulations or stochastic heuristic based inference for replicability purposes, instead of the giga-, terra- (or peta-?) bytes of data or results generated secondarily based on values of the random number chain itself."
  },
  {
    "objectID": "content/articles/basics-of-random-number-generation.html#pseudo-random-number-generators",
    "href": "content/articles/basics-of-random-number-generation.html#pseudo-random-number-generators",
    "title": "Random number generation and management",
    "section": "",
    "text": "Key concept: A pseudo-random number generator deterministically generates a sequence of numbers that are distributed randomly.\nA computer algorithm cannot generate a truly random result. Computer algorithms are deterministic. However, a computer algorithm generate a sequence of numbers based on a series of deterministic calculations that behave like a sequence of random numbers would. These algorithms are known as Pseudo-random number generators (PRNG). Pseuodo-random number generators are deterministic, and, being deterministic, their results—the sequence of random numbers they generate—are predictable.\nA computer program (or algorithm) is a deterministic machine. For some given input, it produces some particular output, based on the its programming. It cannot produce a truly random value in the sense of being , as, for any particular input, an algorithm will produce the same predictable output. For many applications, however, what is needed are not so much values that are absolutely random, but rather a series of numbers that are random with respect to each other, at least up to some or values that can be generated one after another that do not have periodicities, patterns, orders, or “structure” in the sequence, at least for particular scale or size of number set. (For other applications, where true unpredictable as well as non-autocorrelated randomness is strictly needed, computers rely on hardware incorporating some physical source randomness, such as radioactive decay or the wax blobs in lava lamps.)\nA pseudo-random number generator is computer algorithm that can produce a series of values that behave like a random sequence with no observable periodicity or pattern, stastistically or otherwise, for a some very long run of numbers. ( The number of random numbers a particular PRNG can generate before repeating is known as its periodicity. All PRNG’s have periodicities, i.e. will eventually begin repeating the sequence, but good PRNG’s, and the ones we will be using, have HUGE periodicities (\\(2^128\\), to be exact). All PRNG’s have periodicities because of the reality of being needed to be represented on computer with a finite number of bits. The number of bits we use to represent the random numbers (or, the internal state that the PRNG tracks and from which it generates the random numbers) sets the limit to the largest number that can generated. This also sets the limit to the number of numbers that can be generated, This means that at some point or another, the update of one iteration will result in a input value for the next iteration that has been used before in the sequence, resulting in the sequence repeating from that point. A 32-bit PRNG might repeat after \\(2^32\\) numbers, while cryptographic applications (and many modern computing platforms, including Julia) use 128-bit keys, resulting in periodicities of \\(2^128\\). )\nThe sequence of numbers that are generated by PRNG are “random” in most ways, including in terms of quantifying its randomness such as its entropy or fitting a uniform probility distribution better than any other, except for one: predictability of the sequence itself. In turns out, however, that, for most applications, including critical cryptographic ones, predictability of the sequence does not matter. What matters is that there is no ordering, patterns, auto-correlations or cross-correlations, or any sort of structure in the numbers, and that the frequency distribution of values follows that of a uniform probability distribution: every possible value is equally probable to occur at every step And this a PRNG can deliver, given usage that does not exceed their periodicity. (In fact, while the entire sequence of numbers generated by a PRNG is predictable, given the algorithm and initial seed, from one number the next (or for that matter, the previous), is entirely unpredictable without knowing the transition or PRNG function. )\nGiven an initial starting or “seed” value, a PRNG algorithm will compute and return a value, and then use this value as the input value for the next random value generated, thus forming chain of inputs and outputs In more complex algorithms, a separate internal state of a set values is computed from the input value, and a separate function is used to calculate the random number from this internal state. It is this internal state that is passed as input to next step rather than the random number itself. In this way, with each output forming the input for the next step, a sequence of numbers are deterministically generated from the initial seed. The entire sequence itself is deterministically generated from the (deterministic) output of one calculation forming the input the to the nex, starting from the initial seed value. As such, any particular seed value given to the algorithm, e.g., 108 or 99, will always return the exact same sequence of numbers. While not random or unpredictable, and, in fact, quite the opposite—deterministic and predictable—the entire sequence is random in that there is no autocorrelation, patterns, or periodicity in the numbers that might lead to artifactual structure in results that rely in it.\nThis predictability of number sequence from a pseudo-random number generator is not really a practical limitation, and, in fact, has some important roles in software engineering as well as scientific computing. It can be useful, sometimes critically so, in software development: the key to solving a bug is to be able to reliably replicate it, and the predictably of a pseudo-random number sequence allows for debugging of programs that rely on randomness including a lot of scientific research software (e.g. Bayesian Markov chain Monte Carlo inference programs). It can also be very useful in scientific research: many times, it is sufficient to note the random seed used for a particular suite of simulations or stochastic heuristic based inference for replicability purposes, instead of the giga-, terra- (or peta-?) bytes of data or results generated secondarily based on values of the random number chain itself."
  },
  {
    "objectID": "content/articles/basics-of-random-number-generation.html#pseudo-random-number-generator-best-practices-in-julia",
    "href": "content/articles/basics-of-random-number-generation.html#pseudo-random-number-generator-best-practices-in-julia",
    "title": "Random number generation and management",
    "section": "2 Pseudo-random number generator best practices in Julia",
    "text": "2 Pseudo-random number generator best practices in Julia\n\n2.1 Use the default random number generator for convenience\nIn development, exploratary, pilot, or less demanding workflows you can rely on the default random generator, using the Random.seed! function to set the seed.\nusing Random\n\n# Get reference to the global random number generator\nrng = Random.default_rng()\n# Explicitly set its seed\nRandom.seed!(rng, 42)\n\n#  \nrand(Int, 10)\nrand(['A', 'C', 'G', 'T'])\n\n\n2.2 Explicitly manage the random number generator for robust reproducibility and replicability\nIn the full and final production-grade software, you should design all your programs to (1) optionally take a user-specific random number seed and, if not given, generate your own; (2) report and log the random number seed used; and (3) instantiate and use your own random number generator object in all computation, passing it around to different functions or objects that need them.\nusing Random\n\n# Instantiate a PRNG using the \"Xoshiro\" algorithm with the seed value of 42\nrng = Random.Xoshiro(42)\n# Instantiate a PRNG using the \"Mersenne Twister\" with the seed value of 1999\nrng = Random.MersenneTwister(1999)\n\n# Use `rand` with the `rng` to sample an `Int` (integer) value\nrand(rng, Int, 10)\n# Use `rand` with the `rng` to sample a random value from the list\nrand(rng, ['A', 'C', 'G', 'T'])"
  },
  {
    "objectID": "content/articles/basics-of-random-number-generation.html#sample-from-uniform-distributions-using-the-rng-function",
    "href": "content/articles/basics-of-random-number-generation.html#sample-from-uniform-distributions-using-the-rng-function",
    "title": "Random number generation and management",
    "section": "3 Sample from uniform distributions using the rng function",
    "text": "3 Sample from uniform distributions using the rng function\nThe rng function will typically the function you use to generate random variates of different shapes, and sizes and characteristics. This function is available natively with Julia, though you will need to bring it into the global namespace with using Random.\n\n3.1 Sampling from a sequence, list, or set with uniform random probability\n\n\n3.2 Sampling random integers from a fixed range with uniform probability\n\n\n3.3 Sampling random continuous values from \\((0, 1]\\) with uniform probability\n\n\n\n\n\n\nNoteHow a discrete-valued machine generating continuous random values\n\n\n\n\n\nA computer’s RNG (Random Number Generator), generates (pseudo-)random integer values. For continous value, the computer will generate values by sampling from a grid in \\([0, 1)\\).\nAs with the challenges of a deterministic machine generating random values, when requiring random continuous value, we are faced with the challenge of a discrete-value calculating machine dealing with non-integer values. A computer can generate a pseudo-random integer value, \\(k\\), using its Pseudo-Random Number Generator. For continuous values, the generated integer value, \\(k\\) is then scaled to a floating-point \\(x\\) by, for e.g., \\(\\frac{k}{2p}\\), where \\(p\\) is the number usable bits and \\(0 \\le k \\le 2^p - 1\\). The result in floating point value in the range \\(0 \\le x &lt; 1\\).\nWhile 1 is excluded from the range, this does not change the distribution. A continuous uniform distribution on \\([0, 1]\\) assigns probability zero to any single point, include \\(0\\) or \\(1\\) in that range, so this exclusion of 1 does not change the characteristics of the distribution. (With continuous distributions, we do not ask what is the probability of observing any particular value. We ask is the probability of observing a range of values.)\nLet\n\n\\(p\\) = number of mantissa bits of the target floating-point type (\\(p=53\\) for Float64)\n\\(k\\) drawn uniformly from\n\n\\[\n{0,1,\\dots,2^p - 1}\n\\]\nDefine\n\\[\nx = \\frac{k}{2^p}.\n\\]\nThen:\n\nThe mapping \\(k \\mapsto x\\) is bijective\nEach possible \\(x\\) has probability exactly \\(2^{-p}\\)\nThe support is\n\n\\[\n\\left\\{ 0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\dots, \\frac{2^p-1}{2^p} \\right\\}\n\\subset [0,1)\n\\]\nNote this is a discrete uniform distribution over the set of values \\(\\{0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\ldots, \\frac{2^p-1}{2^p}\\}\\), not a continuous one. The operation bins the range \\([0, 1)\\) into \\(2^p\\) equal width bins of \\(\\frac{1}{1^p}\\) width. For Float64 this result in \\(2^{53} \\approx 9 \\times 10^{15}\\) bins of width \\(2^{-53} \\approx 1.11 \\times 10^{-16}\\)."
  },
  {
    "objectID": "content/articles/basics-of-random-number-generation.html#sampling-a-random-event-of-a-particular-probaility",
    "href": "content/articles/basics-of-random-number-generation.html#sampling-a-random-event-of-a-particular-probaility",
    "title": "Random number generation and management",
    "section": "4 Sampling a random event of a particular probaility",
    "text": "4 Sampling a random event of a particular probaility"
  },
  {
    "objectID": "content/articles/basics-of-figures.html#proficiencies",
    "href": "content/articles/basics-of-figures.html#proficiencies",
    "title": "First steps in visualization",
    "section": "",
    "text": "Creating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ.\n\n\n\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure()\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the axes\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\nscatter!(ax, x_vals, y_vals)\n\n# We can save the figure to file\n# savefig(figure, \"scatter1.pdf\")\n\n# Or just display it in-situ\nfigure"
  },
  {
    "objectID": "content/articles/04-basics-of-figures.html",
    "href": "content/articles/04-basics-of-figures.html",
    "title": "Basics of visualization",
    "section": "",
    "text": "Proficiencies\n\nFor pilot and exploratory work: plotting without explicit Figure and Axis objects.\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ."
  },
  {
    "objectID": "content/articles/04-basics-of-figures.html#proficiencies",
    "href": "content/articles/04-basics-of-figures.html#proficiencies",
    "title": "Basics of visualization",
    "section": "",
    "text": "For pilot and exploratory work: creating a plot without using an explicit\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ."
  },
  {
    "objectID": "content/articles/04-basics-of-figures.html#recipes",
    "href": "content/articles/04-basics-of-figures.html#recipes",
    "title": "Basics of visualization",
    "section": "1 Recipes",
    "text": "1 Recipes\n\nusing CairoMakie\nx_vals = 1:100\ny_vals = map(x -&gt; 3x + 2, x_vals)\nscatter(x_vals, y_vals)\n\n\n\n\n\n# Load the graphical library definitions\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Draw a scatter plot onto the Axis object\nscatter!(ax, x_vals, y_vals)\n\n# We can save the figure to file\n# savefig(figure, \"scatter1.pdf\")\n\n# Or just display it in-situ\nfigure"
  },
  {
    "objectID": "content/articles/02-basics-of-visualizing-mathematical-models.html",
    "href": "content/articles/02-basics-of-visualizing-mathematical-models.html",
    "title": "Basics of visualizing mathematical models: evolutionary dynamics of virulence-transmission trade-off models",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines parasite fitness as a product of capacity for transmission success weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to virulence-related damage to the host.\nThe fitness of a parasite can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the parasite fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is the a measure of parasite transmission success, an index of the number of hosts potentially infected, given full transmission opportunity,\n\\(f(z)\\), a “declining function of \\(z\\)” (\\(f(z)\\) decreases as \\(z\\) increases) is the cost or penalty factor accounting for reduction in transmission opportunity or windows due to depletion of host or host resources or host fitness.\n\nBy optimizing the function with respect to the parameter \\(z\\), that is, finding the value of \\(z\\) that maximizes \\(w\\).\n\n\n\n\n\n\n\nTipOptimization\n\n\n\n\n\n\n\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\]\n$$ {#eq-frank1996-single-pathogen-fitness-linear}"
  },
  {
    "objectID": "content/articles/02-basics-of-visualizing-mathematical-models.html#the-trade-off-function",
    "href": "content/articles/02-basics-of-visualizing-mathematical-models.html#the-trade-off-function",
    "title": "Basics of visualizing mathematical models",
    "section": "",
    "text": "The classical trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)+},\n\\]\nwhere:\n\n\\(R_0\\)\n\\(\\nu\\)\n\\(\\beta(\\nu)\\)\n\\(N\\)\n\\(\\delta\\)\n\\(c(\\nu)\\)\n\n(Frank 1996) provides a reparameterization of this,\n\\[\nw = z f(z),\n\\]\nwhere:\n\n\\(w\\) is the parasite fitness, corresponding to \\(R_0\\).\n\\(z\\) is the parasite transmission success, corresponding to the numerator in Expression (1) of the paper for \\(R_0\\), \\(z = \\beta(\\nu)N\\).\n\\(f(z)\\) is the level of damage to the host (“virulence”), corresponding to the transmission success of \\(z\\)."
  },
  {
    "objectID": "content/articles/02-basics-of-visualizing-mathematical-models.html#the-virulence-transmission-trade-off-function",
    "href": "content/articles/02-basics-of-visualizing-mathematical-models.html#the-virulence-transmission-trade-off-function",
    "title": "Basics of visualizing mathematical models: evolutionary dynamics of virulence-transmission trade-off models",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines parasite fitness as a product of capacity for transmission success weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to virulence-related damage to the host.\nThe fitness of a parasite can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the parasite fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is the a measure of parasite transmission success, an index of the number of hosts potentially infected, given full transmission opportunity,\n\\(f(z)\\), a “declining function of \\(z\\)” (\\(f(z)\\) decreases as \\(z\\) increases) is the cost or penalty factor accounting for reduction in transmission opportunity or windows due to depletion of host or host resources or host fitness.\n\nBy optimizing the function with respect to the parameter \\(z\\), that is, finding the value of \\(z\\) that maximizes \\(w\\).\n\n\n\n\n\n\n\nTipOptimization\n\n\n\n\n\n\n\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\]\n$$ {#eq-frank1996-single-pathogen-fitness-linear}"
  },
  {
    "objectID": "content/articles/02_basics-of-visualizing-mathematical-models_01.html",
    "href": "content/articles/02_basics-of-visualizing-mathematical-models_01.html",
    "title": "Basics of visualizing mathematical models in Julia: generating data using range",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated."
  },
  {
    "objectID": "content/articles/02+basics-of-visualizing-mathematical-models_02.html",
    "href": "content/articles/02+basics-of-visualizing-mathematical-models_02.html",
    "title": "Basics of visualizing mathematical models: evolutionary dynamics of virulence-transmission trade-off models",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa.\n\nIn this formulation, If we consider that pathogen reproductive intensity Under adaptive evolution, we would expect that fitness of the parasite, \\(w\\), would be maximized.\nWe can optimizing the function by maximizing with respect to the parameter \\(z\\), that is, finding the value of \\(z\\) that maximizes \\(w\\), we find the\n\n\n\n\n\n\n\nTipOptimization\n\n\n\n\n\n\n\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\]\n$$ {#eq-frank1996-single-pathogen-fitness-linear}"
  },
  {
    "objectID": "content/articles/02+basics-of-visualizing-mathematical-models_02.html#the-virulence-transmission-trade-off-function",
    "href": "content/articles/02+basics-of-visualizing-mathematical-models_02.html#the-virulence-transmission-trade-off-function",
    "title": "Basics of visualizing mathematical models: evolutionary dynamics of virulence-transmission trade-off models",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa.\n\nIn this formulation, If we consider that pathogen reproductive intensity Under adaptive evolution, we would expect that fitness of the parasite, \\(w\\), would be maximized.\nWe can optimizing the function by maximizing with respect to the parameter \\(z\\), that is, finding the value of \\(z\\) that maximizes \\(w\\), we find the\n\n\n\n\n\n\n\nTipOptimization\n\n\n\n\n\n\n\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\]\n$$ {#eq-frank1996-single-pathogen-fitness-linear}"
  },
  {
    "objectID": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#linear-equation",
    "href": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#linear-equation",
    "title": "Basics of visualizing mathematical models: exploratory plotting in Julia",
    "section": "1 Linear equation",
    "text": "1 Linear equation\n\nusing CairoMakie\nX = -10:0.01:10\nY = map(x -&gt; 4x + 2, X)\nscatter(X, Y)"
  },
  {
    "objectID": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#generating-a-sequence-over-a-range",
    "href": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#generating-a-sequence-over-a-range",
    "title": "Basics of visualizing mathematical models: exploratory plotting in Julia",
    "section": "1 Generating a sequence over a range",
    "text": "1 Generating a sequence over a range\nWe can generate a set of \\(x\\) values over a particular continuousd range of values in a number of ways in Julia, with the ability to specify the resolution (or sampling density) by interval, step or bin size, or the number of values.\n# A\nx_values = range(0, 10, step = 1)\nx_values = range(0, 10, length = 11)\nFor the purposes of visualization, we do not need to generate data over the entire \\((-\\infty, \\infty)\\) range, as the relationships does change, and, similarly, a resolution or step size of 0.1 is sufficient for sampled discrete points to show the pattern.\n\nusing CairoMakie\nX = -10:0.01:10\nY = map(x -&gt; 6x + 4, X)\nscatter(X, Y)\n\n\n\n\n\n\nExercise\nUse Julia isualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values to see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001"
  },
  {
    "objectID": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#stochastically-sampling-from-a-range",
    "href": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#stochastically-sampling-from-a-range",
    "title": "Basics of visualizing mathematical models: exploratory plotting in Julia",
    "section": "2 Stochastically sampling from a range",
    "text": "2 Stochastically sampling from a range\nAs model structures and elements get more complex"
  },
  {
    "objectID": "content/articles/04-basics-of-figures.html#basic-plotting",
    "href": "content/articles/04-basics-of-figures.html#basic-plotting",
    "title": "Basics of visualization",
    "section": "1 Basic plotting",
    "text": "1 Basic plotting\n\nusing CairoMakie\nx_vals = 1:100\ny_vals = map(x -&gt; 3x + 2, x_vals)\nscatter(x_vals, y_vals)"
  },
  {
    "objectID": "content/articles/04-basics-of-figures.html#plotting-and-saving-with-explicit-axis-and-figure-management",
    "href": "content/articles/04-basics-of-figures.html#plotting-and-saving-with-explicit-axis-and-figure-management",
    "title": "Basics of visualization",
    "section": "2 Plotting and saving with explicit Axis and Figure management",
    "text": "2 Plotting and saving with explicit Axis and Figure management\n\n# Load the graphical library definitions\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Draw a scatter plot onto the Axis object\nscatter!(ax, x_vals, y_vals)\n\n# We can save the figure to file\n# savefig(figure, \"scatter1.pdf\")\n\n# Or just display it in-situ\nfigure"
  },
  {
    "objectID": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#generating-a-sequence-of-values-with-the-range-function",
    "href": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#generating-a-sequence-of-values-with-the-range-function",
    "title": "Basics of visualizing mathematical models in Julia: generating data using range",
    "section": "1 Generating a sequence of values with the range function",
    "text": "1 Generating a sequence of values with the range function\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue"
  },
  {
    "objectID": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#calculating-and-visualizing-function-values-over-a-sequence",
    "href": "content/articles/02_basics-of-visualizing-mathematical-models_01.html#calculating-and-visualizing-function-values-over-a-sequence",
    "title": "Basics of visualizing mathematical models in Julia: generating data using range",
    "section": "2 Calculating and visualizing function values over a sequence",
    "text": "2 Calculating and visualizing function values over a sequence\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/02-02_linear-single-strain-virulence-evolution-model.html",
    "href": "content/02_basics-of-visualizing-mathematical-models/02-02_linear-single-strain-virulence-evolution-model.html",
    "title": "Basics of visualizing mathematical models: evolutionary dynamics of virulence-transmission trade-off models",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa.\n\nIn this formulation, If we consider that pathogen reproductive intensity Under adaptive evolution, we would expect that fitness of the parasite, \\(w\\), would be maximized.\nWe can optimizing the function by maximizing with respect to the parameter \\(z\\), that is, finding the value of \\(z\\) that maximizes \\(w\\), we find the\n\n\n\n\n\n\n\nTipOptimization\n\n\n\n\n\n\n\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\]\n$$ {#eq-frank1996-single-pathogen-fitness-linear}"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/02-02_linear-single-strain-virulence-evolution-model.html#the-virulence-transmission-trade-off-function",
    "href": "content/02_basics-of-visualizing-mathematical-models/02-02_linear-single-strain-virulence-evolution-model.html#the-virulence-transmission-trade-off-function",
    "title": "Basics of visualizing mathematical models: evolutionary dynamics of virulence-transmission trade-off models",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa.\n\nIn this formulation, If we consider that pathogen reproductive intensity Under adaptive evolution, we would expect that fitness of the parasite, \\(w\\), would be maximized.\nWe can optimizing the function by maximizing with respect to the parameter \\(z\\), that is, finding the value of \\(z\\) that maximizes \\(w\\), we find the\n\n\n\n\n\n\n\nTipOptimization\n\n\n\n\n\n\n\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\]\n$$ {#eq-frank1996-single-pathogen-fitness-linear}"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html",
    "href": "content/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html",
    "title": "Basics of mathematical modeling in Julia: generating sequences of values using the range function",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated."
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#generating-a-sequence-of-values-with-the-range-function",
    "href": "content/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#generating-a-sequence-of-values-with-the-range-function",
    "title": "Basics of mathematical modeling in Julia: generating sequences of values using the range function",
    "section": "1 Generating a sequence of values with the range function",
    "text": "1 Generating a sequence of values with the range function\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#calculating-and-visualizing-function-values-over-a-sequence",
    "href": "content/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#calculating-and-visualizing-function-values-over-a-sequence",
    "title": "Basics of mathematical modeling in Julia: generating sequences of values using the range function",
    "section": "2 Calculating and visualizing function values over a sequence",
    "text": "2 Calculating and visualizing function values over a sequence\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)"
  },
  {
    "objectID": "content/01_orientation-and-tooling/01-02_shell-file-system-essentials.html",
    "href": "content/01_orientation-and-tooling/01-02_shell-file-system-essentials.html",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/01_orientation-and-tooling/index.html",
    "href": "content/01_orientation-and-tooling/index.html",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": " 01_workstation-setup-and-tooling ├──  _annex │ └──  timholy–setting-up-vscode-and-julia │ ├──  figures │ │ ├──  julia_extension.png │ │ ├──  julia_term_1.png │ │ ├──  vscode_ctrl_shift_p.png │ │ └──  vscode_with_julia_repl.png │ └──  index.qmd ├──  01_workstation-essentials.qmd ├──  02_filesystem-essentials.qmd ├──  03_git-and-github.qmd ├──  04_julia-environments-and-projects.qmd ├──  05_quarto.qmd ├──  06_vscode-and-extensions.qmd ├──  07_julia-quarto-project.qmd ├──  _outline.qmd └──  index.qmd\n\n\n\n Back to top"
  },
  {
    "objectID": "content/01_orientation-and-tooling/01-01_introduction-to-the-computing-ecosystem.html",
    "href": "content/01_orientation-and-tooling/01-01_introduction-to-the-computing-ecosystem.html",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/01_orientation-and-tooling/01-04_julia-runtime-programs-repl-files.html",
    "href": "content/01_orientation-and-tooling/01-04_julia-runtime-programs-repl-files.html",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/01_orientation-and-tooling/01-03_installing-julia.html",
    "href": "content/01_orientation-and-tooling/01-03_installing-julia.html",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/01_orientation-and-tooling/01-05_julia-environments-packages-and-projects.html",
    "href": "content/01_orientation-and-tooling/01-05_julia-environments-packages-and-projects.html",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html",
    "href": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html",
    "title": "Random number generation and management",
    "section": "",
    "text": "Key concept: A pseudo-random number generator deterministically generates a sequence of numbers that are distributed randomly.\nA computer algorithm cannot generate a truly random result. Computer algorithms are deterministic. However, a computer algorithm generate a sequence of numbers based on a series of deterministic calculations that behave like a sequence of random numbers would. These algorithms are known as Pseudo-random number generators (PRNG). Pseuodo-random number generators are deterministic, and, being deterministic, their results—the sequence of random numbers they generate—are predictable.\nA computer program (or algorithm) is a deterministic machine. For some given input, it produces some particular output, based on the its programming. It cannot produce a truly random value in the sense of being , as, for any particular input, an algorithm will produce the same predictable output. For many applications, however, what is needed are not so much values that are absolutely random, but rather a series of numbers that are random with respect to each other, at least up to some or values that can be generated one after another that do not have periodicities, patterns, orders, or “structure” in the sequence, at least for particular scale or size of number set. (For other applications, where true unpredictable as well as non-autocorrelated randomness is strictly needed, computers rely on hardware incorporating some physical source randomness, such as radioactive decay or the wax blobs in lava lamps.)\nA pseudo-random number generator is computer algorithm that can produce a series of values that behave like a random sequence with no observable periodicity or pattern, stastistically or otherwise, for a some very long run of numbers. ( The number of random numbers a particular PRNG can generate before repeating is known as its periodicity. All PRNG’s have periodicities, i.e. will eventually begin repeating the sequence, but good PRNG’s, and the ones we will be using, have HUGE periodicities (\\(2^128\\), to be exact). All PRNG’s have periodicities because of the reality of being needed to be represented on computer with a finite number of bits. The number of bits we use to represent the random numbers (or, the internal state that the PRNG tracks and from which it generates the random numbers) sets the limit to the largest number that can generated. This also sets the limit to the number of numbers that can be generated, This means that at some point or another, the update of one iteration will result in a input value for the next iteration that has been used before in the sequence, resulting in the sequence repeating from that point. A 32-bit PRNG might repeat after \\(2^32\\) numbers, while cryptographic applications (and many modern computing platforms, including Julia) use 128-bit keys, resulting in periodicities of \\(2^128\\). )\nThe sequence of numbers that are generated by PRNG are “random” in most ways, including in terms of quantifying its randomness such as its entropy or fitting a uniform probility distribution better than any other, except for one: predictability of the sequence itself. In turns out, however, that, for most applications, including critical cryptographic ones, predictability of the sequence does not matter. What matters is that there is no ordering, patterns, auto-correlations or cross-correlations, or any sort of structure in the numbers, and that the frequency distribution of values follows that of a uniform probability distribution: every possible value is equally probable to occur at every step And this a PRNG can deliver, given usage that does not exceed their periodicity. (In fact, while the entire sequence of numbers generated by a PRNG is predictable, given the algorithm and initial seed, from one number the next (or for that matter, the previous), is entirely unpredictable without knowing the transition or PRNG function. )\nGiven an initial starting or “seed” value, a PRNG algorithm will compute and return a value, and then use this value as the input value for the next random value generated, thus forming chain of inputs and outputs In more complex algorithms, a separate internal state of a set values is computed from the input value, and a separate function is used to calculate the random number from this internal state. It is this internal state that is passed as input to next step rather than the random number itself. In this way, with each output forming the input for the next step, a sequence of numbers are deterministically generated from the initial seed. The entire sequence itself is deterministically generated from the (deterministic) output of one calculation forming the input the to the nex, starting from the initial seed value. As such, any particular seed value given to the algorithm, e.g., 108 or 99, will always return the exact same sequence of numbers. While not random or unpredictable, and, in fact, quite the opposite—deterministic and predictable—the entire sequence is random in that there is no autocorrelation, patterns, or periodicity in the numbers that might lead to artifactual structure in results that rely in it.\nThis predictability of number sequence from a pseudo-random number generator is not really a practical limitation, and, in fact, has some important roles in software engineering as well as scientific computing. It can be useful, sometimes critically so, in software development: the key to solving a bug is to be able to reliably replicate it, and the predictably of a pseudo-random number sequence allows for debugging of programs that rely on randomness including a lot of scientific research software (e.g. Bayesian Markov chain Monte Carlo inference programs). It can also be very useful in scientific research: many times, it is sufficient to note the random seed used for a particular suite of simulations or stochastic heuristic based inference for replicability purposes, instead of the giga-, terra- (or peta-?) bytes of data or results generated secondarily based on values of the random number chain itself."
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#pseudo-random-number-generators",
    "href": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#pseudo-random-number-generators",
    "title": "Random number generation and management",
    "section": "",
    "text": "Key concept: A pseudo-random number generator deterministically generates a sequence of numbers that are distributed randomly.\nA computer algorithm cannot generate a truly random result. Computer algorithms are deterministic. However, a computer algorithm generate a sequence of numbers based on a series of deterministic calculations that behave like a sequence of random numbers would. These algorithms are known as Pseudo-random number generators (PRNG). Pseuodo-random number generators are deterministic, and, being deterministic, their results—the sequence of random numbers they generate—are predictable.\nA computer program (or algorithm) is a deterministic machine. For some given input, it produces some particular output, based on the its programming. It cannot produce a truly random value in the sense of being , as, for any particular input, an algorithm will produce the same predictable output. For many applications, however, what is needed are not so much values that are absolutely random, but rather a series of numbers that are random with respect to each other, at least up to some or values that can be generated one after another that do not have periodicities, patterns, orders, or “structure” in the sequence, at least for particular scale or size of number set. (For other applications, where true unpredictable as well as non-autocorrelated randomness is strictly needed, computers rely on hardware incorporating some physical source randomness, such as radioactive decay or the wax blobs in lava lamps.)\nA pseudo-random number generator is computer algorithm that can produce a series of values that behave like a random sequence with no observable periodicity or pattern, stastistically or otherwise, for a some very long run of numbers. ( The number of random numbers a particular PRNG can generate before repeating is known as its periodicity. All PRNG’s have periodicities, i.e. will eventually begin repeating the sequence, but good PRNG’s, and the ones we will be using, have HUGE periodicities (\\(2^128\\), to be exact). All PRNG’s have periodicities because of the reality of being needed to be represented on computer with a finite number of bits. The number of bits we use to represent the random numbers (or, the internal state that the PRNG tracks and from which it generates the random numbers) sets the limit to the largest number that can generated. This also sets the limit to the number of numbers that can be generated, This means that at some point or another, the update of one iteration will result in a input value for the next iteration that has been used before in the sequence, resulting in the sequence repeating from that point. A 32-bit PRNG might repeat after \\(2^32\\) numbers, while cryptographic applications (and many modern computing platforms, including Julia) use 128-bit keys, resulting in periodicities of \\(2^128\\). )\nThe sequence of numbers that are generated by PRNG are “random” in most ways, including in terms of quantifying its randomness such as its entropy or fitting a uniform probility distribution better than any other, except for one: predictability of the sequence itself. In turns out, however, that, for most applications, including critical cryptographic ones, predictability of the sequence does not matter. What matters is that there is no ordering, patterns, auto-correlations or cross-correlations, or any sort of structure in the numbers, and that the frequency distribution of values follows that of a uniform probability distribution: every possible value is equally probable to occur at every step And this a PRNG can deliver, given usage that does not exceed their periodicity. (In fact, while the entire sequence of numbers generated by a PRNG is predictable, given the algorithm and initial seed, from one number the next (or for that matter, the previous), is entirely unpredictable without knowing the transition or PRNG function. )\nGiven an initial starting or “seed” value, a PRNG algorithm will compute and return a value, and then use this value as the input value for the next random value generated, thus forming chain of inputs and outputs In more complex algorithms, a separate internal state of a set values is computed from the input value, and a separate function is used to calculate the random number from this internal state. It is this internal state that is passed as input to next step rather than the random number itself. In this way, with each output forming the input for the next step, a sequence of numbers are deterministically generated from the initial seed. The entire sequence itself is deterministically generated from the (deterministic) output of one calculation forming the input the to the nex, starting from the initial seed value. As such, any particular seed value given to the algorithm, e.g., 108 or 99, will always return the exact same sequence of numbers. While not random or unpredictable, and, in fact, quite the opposite—deterministic and predictable—the entire sequence is random in that there is no autocorrelation, patterns, or periodicity in the numbers that might lead to artifactual structure in results that rely in it.\nThis predictability of number sequence from a pseudo-random number generator is not really a practical limitation, and, in fact, has some important roles in software engineering as well as scientific computing. It can be useful, sometimes critically so, in software development: the key to solving a bug is to be able to reliably replicate it, and the predictably of a pseudo-random number sequence allows for debugging of programs that rely on randomness including a lot of scientific research software (e.g. Bayesian Markov chain Monte Carlo inference programs). It can also be very useful in scientific research: many times, it is sufficient to note the random seed used for a particular suite of simulations or stochastic heuristic based inference for replicability purposes, instead of the giga-, terra- (or peta-?) bytes of data or results generated secondarily based on values of the random number chain itself."
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#pseudo-random-number-generator-best-practices-in-julia",
    "href": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#pseudo-random-number-generator-best-practices-in-julia",
    "title": "Random number generation and management",
    "section": "2 Pseudo-random number generator best practices in Julia",
    "text": "2 Pseudo-random number generator best practices in Julia\n\n2.1 Use the default random number generator for convenience\nIn development, exploratary, pilot, or less demanding workflows you can rely on the default random generator, using the Random.seed! function to set the seed.\nusing Random\n\n# Get reference to the global random number generator\nrng = Random.default_rng()\n# Explicitly set its seed\nRandom.seed!(rng, 42)\n\n#  \nrand(Int, 10)\nrand(['A', 'C', 'G', 'T'])\n\n\n2.2 Explicitly manage the random number generator for robust reproducibility and replicability\nIn the full and final production-grade software, you should design all your programs to (1) optionally take a user-specific random number seed and, if not given, generate your own; (2) report and log the random number seed used; and (3) instantiate and use your own random number generator object in all computation, passing it around to different functions or objects that need them.\nusing Random\n\n# Instantiate a PRNG using the \"Xoshiro\" algorithm with the seed value of 42\nrng = Random.Xoshiro(42)\n# Instantiate a PRNG using the \"Mersenne Twister\" with the seed value of 1999\nrng = Random.MersenneTwister(1999)\n\n# Use `rand` with the `rng` to sample an `Int` (integer) value\nrand(rng, Int, 10)\n# Use `rand` with the `rng` to sample a random value from the list\nrand(rng, ['A', 'C', 'G', 'T'])"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#sample-from-uniform-distributions-using-the-rng-function",
    "href": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#sample-from-uniform-distributions-using-the-rng-function",
    "title": "Random number generation and management",
    "section": "3 Sample from uniform distributions using the rng function",
    "text": "3 Sample from uniform distributions using the rng function\nThe rng function will typically the function you use to generate random variates of different shapes, and sizes and characteristics. This function is available natively with Julia, though you will need to bring it into the global namespace with using Random.\n\n3.1 Sampling from a sequence, list, or set with uniform random probability\n\n\n3.2 Sampling random integers from a fixed range with uniform probability\n\n\n3.3 Sampling random continuous values from \\((0, 1]\\) with uniform probability\n\n\n\n\n\n\nNoteHow a discrete-valued machine generating continuous random values\n\n\n\n\n\nA computer’s RNG (Random Number Generator), generates (pseudo-)random integer values. For continous value, the computer will generate values by sampling from a grid in \\([0, 1)\\).\nAs with the challenges of a deterministic machine generating random values, when requiring random continuous value, we are faced with the challenge of a discrete-value calculating machine dealing with non-integer values. A computer can generate a pseudo-random integer value, \\(k\\), using its Pseudo-Random Number Generator. For continuous values, the generated integer value, \\(k\\) is then scaled to a floating-point \\(x\\) by, for e.g., \\(\\frac{k}{2p}\\), where \\(p\\) is the number usable bits and \\(0 \\le k \\le 2^p - 1\\). The result in floating point value in the range \\(0 \\le x &lt; 1\\).\nWhile 1 is excluded from the range, this does not change the distribution. A continuous uniform distribution on \\([0, 1]\\) assigns probability zero to any single point, include \\(0\\) or \\(1\\) in that range, so this exclusion of 1 does not change the characteristics of the distribution. (With continuous distributions, we do not ask what is the probability of observing any particular value. We ask is the probability of observing a range of values.)\nLet\n\n\\(p\\) = number of mantissa bits of the target floating-point type (\\(p=53\\) for Float64)\n\\(k\\) drawn uniformly from\n\n\\[\n{0,1,\\dots,2^p - 1}\n\\]\nDefine\n\\[\nx = \\frac{k}{2^p}.\n\\]\nThen:\n\nThe mapping \\(k \\mapsto x\\) is bijective\nEach possible \\(x\\) has probability exactly \\(2^{-p}\\)\nThe support is\n\n\\[\n\\left\\{ 0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\dots, \\frac{2^p-1}{2^p} \\right\\}\n\\subset [0,1)\n\\]\nNote this is a discrete uniform distribution over the set of values \\(\\{0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\ldots, \\frac{2^p-1}{2^p}\\}\\), not a continuous one. The operation bins the range \\([0, 1)\\) into \\(2^p\\) equal width bins of \\(\\frac{1}{1^p}\\) width. For Float64 this result in \\(2^{53} \\approx 9 \\times 10^{15}\\) bins of width \\(2^{-53} \\approx 1.11 \\times 10^{-16}\\)."
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#sampling-a-random-event-of-a-particular-probaility",
    "href": "content/02_basics-of-visualizing-mathematical-models/03-01_basics-of-random-number-generation.html#sampling-a-random-event-of-a-particular-probaility",
    "title": "Random number generation and management",
    "section": "4 Sampling a random event of a particular probaility",
    "text": "4 Sampling a random event of a particular probaility"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/04-basics-of-figures.html",
    "href": "content/02_basics-of-visualizing-mathematical-models/04-basics-of-figures.html",
    "title": "Basics of visualization",
    "section": "",
    "text": "Proficiencies\n\nFor pilot and exploratory work: plotting without explicit Figure and Axis objects.\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ."
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/04-basics-of-figures.html#basic-plotting",
    "href": "content/02_basics-of-visualizing-mathematical-models/04-basics-of-figures.html#basic-plotting",
    "title": "Basics of visualization",
    "section": "1 Basic plotting",
    "text": "1 Basic plotting\n\nusing CairoMakie\nx_vals = 1:100\ny_vals = map(x -&gt; 3x + 2, x_vals)\nscatter(x_vals, y_vals)"
  },
  {
    "objectID": "content/02_basics-of-visualizing-mathematical-models/04-basics-of-figures.html#plotting-and-saving-with-explicit-axis-and-figure-management",
    "href": "content/02_basics-of-visualizing-mathematical-models/04-basics-of-figures.html#plotting-and-saving-with-explicit-axis-and-figure-management",
    "title": "Basics of visualization",
    "section": "2 Plotting and saving with explicit Axis and Figure management",
    "text": "2 Plotting and saving with explicit Axis and Figure management\n\n# Load the graphical library definitions\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Draw a scatter plot onto the Axis object\nscatter!(ax, x_vals, y_vals)\n\n# We can save the figure to file\n# savefig(figure, \"scatter1.pdf\")\n\n# Or just display it in-situ\nfigure"
  },
  {
    "objectID": "content/models/frank1996model_pathogen-fitness-single-strain.html",
    "href": "content/models/frank1996model_pathogen-fitness-single-strain.html",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "",
    "text": "(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html",
    "title": "Basics of visualization",
    "section": "",
    "text": "Proficiencies\n\nFor pilot and exploratory work: plotting without explicit Figure and Axis objects.\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting",
    "title": "Basics of visualization",
    "section": "1 Plotting",
    "text": "1 Plotting\n\n\n# Load the graphical module\nusing CairoMakie\n\n# Generate x-values from 1 to 100\nx_vals = 1:100\n\n# Generate y-values from function applied to x-values\ny_vals = map(x -&gt; 3x + 2, x_vals)\n\n# Plot (and display) using the `scatter` function\nrender = scatter(x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-and-saving-with-explicit-axis-and-figure-management",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-and-saving-with-explicit-axis-and-figure-management",
    "title": "Basics of visualization",
    "section": "2 Plotting and saving with explicit Axis and Figure management",
    "text": "2 Plotting and saving with explicit Axis and Figure management\n\n# Load the graphical module\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Plot using the `scatter!` function\n# Note: the name is `scatter!` not `scatter`, and we pass \n# in the Axis object `ax` as the first argument\nscatter!(ax, x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure\n\nScatter{Tuple{Vector{Point{2, Float64}}}}"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html",
    "title": "Basics of mathematical modeling in Julia: generating sequences of values using the range function",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#generating-a-sequence-of-values-with-the-range-function",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#generating-a-sequence-of-values-with-the-range-function",
    "title": "Basics of mathematical modeling in Julia: generating sequences of values using the range function",
    "section": "1 Generating a sequence of values with the range function",
    "text": "1 Generating a sequence of values with the range function\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#calculating-and-visualizing-function-values-over-a-sequence",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#calculating-and-visualizing-function-values-over-a-sequence",
    "title": "Basics of mathematical modeling in Julia: generating sequences of values using the range function",
    "section": "2 Calculating and visualizing function values over a sequence",
    "text": "2 Calculating and visualizing function values over a sequence\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_visualizing-single-strain-virulence-evolution.html",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_visualizing-single-strain-virulence-evolution.html",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "",
    "text": "The single-strain pathogen fitness model\n\n\n\n Back to top"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "",
    "text": "The single-strain pathogen fitness model is given as (Frank 1996):\n\\[\n\\begin{aligned}\nw = z (1 - \\alpha z)\n\\end{aligned}\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is a measure of pathogen fitness,\n\\(z\\) is a measure of the parasite host exploitation severity, correlating positively with parasite reproductive and host colonization capacity, and\n\\(\\alpha z\\) is a measure of virulence, the damage a parasite does to the host as a result of exploitation \\(z\\), with \\(\\alpha\\) a scaling factor, weighting the damage of the parasite reproductive activity in reducing the host resources available to the parasite."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-implict-axis-and-figure",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-implict-axis-and-figure",
    "title": "Basics of visualization",
    "section": "1 Plotting with implict Axis and Figure",
    "text": "1 Plotting with implict Axis and Figure\n\n\n# Load the graphical module\nusing CairoMakie\n\n# Generate x-values from 1 to 100\nx_vals = 1:100\n\n# Generate y-values from function applied to x-values\ny_vals = map(x -&gt; 3x + 2, x_vals)\n\n# Plot (and display) using the `scatter` function\nrender = scatter(x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-explicit-axis-and-figure-management",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-explicit-axis-and-figure-management",
    "title": "Basics of visualization",
    "section": "2 Plotting with explicit Axis and Figure management",
    "text": "2 Plotting with explicit Axis and Figure management\n\n# Load the graphical module\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Plot using the `scatter!` function\n# Note: the name is `scatter!` not `scatter`, and we pass \n# in the Axis object `ax` as the first argument\nscatter!(ax, x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure\n\nScatter{Tuple{Vector{Point{2, Float64}}}}"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#pathogen-fitness-function",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#pathogen-fitness-function",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "",
    "text": "The single-strain pathogen fitness model is given as (Frank 1996):\n\\[\n\\begin{aligned}\nw = z (1 - \\alpha z)\n\\end{aligned}\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is a measure of pathogen fitness,\n\\(z\\) is a measure of the parasite host exploitation severity, correlating positively with parasite reproductive and host colonization capacity, and\n\\(\\alpha z\\) is a measure of virulence, the damage a parasite does to the host as a result of exploitation \\(z\\), with \\(\\alpha\\) a scaling factor, weighting the damage of the parasite reproductive activity in reducing the host resources available to the parasite."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#behavior-under-adaptive-evolution",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#behavior-under-adaptive-evolution",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "2 Behavior under adaptive evolution",
    "text": "2 Behavior under adaptive evolution\nLet us consider host exploitation severity, \\(z\\), as a heritable trait that affects transmission success and virulence, and let \\(w(z, \\alpha)\\) be the fitness of of a parasite with host exploitation severity trait value \\(z\\), given some virulence impact weight \\(\\alpha\\).\nIf parasites vary in \\(z\\) and this variation is heritable, then strategies with larger \\(w(z)\\) tend to leave more descendants (i.e., spread more effectively).\nIn this simplified model, we therefore expect evolution to favor values of \\(z\\) that make \\(w(z)\\) as large as possible, so we look for the value of \\(z\\) that maximizes \\(w(z)\\)."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-strength",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-strength",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "3 Visualization of fitness relationship with host exploitation strength",
    "text": "3 Visualization of fitness relationship with host exploitation strength\nTo visualize the behavior of this model—how pathogen fitness varies with host exploitation strength, and which exploitation levels balance transmission gains against virulence costs—we can generate model values and plot them.\nThe response variable is \\(w\\), pathogen fitness, modeled as a function of two parameters, \\(z\\) and \\(\\alpha\\):\n\\[\nw(z;\\alpha) = z(1-\\alpha z).\n\\]\nConceptually, we can treat this as a simple optimization problem in which:\n\n\\(z\\) is the adjustable trait (a “tuning parameter” or control variable) describing host exploitation intensity, and\n\\(\\alpha\\) is an environmental or biological scaling parameter that sets how quickly increasing exploitation \\(z\\) translates into virulence damage (i.e., how strongly host damage reduces transmission opportunity).\n\nFor any fixed \\(\\alpha&gt;0\\), varying \\(z\\) traces out a fitness curve \\(w\\) versus \\(z\\). Plotting this curve shows three qualitative regimes:\n\nsmall \\(z\\): low fitness because transmission capacity is weak,\nintermediate \\(z\\): fitness increases as transmission gains dominate,\nlarge \\(z\\): fitness decreases as virulence costs dominate (the term \\(1-\\alpha z\\) becomes small, and eventually negative outside the biologically meaningful range).\n\nBecause \\(f(z)=1-\\alpha z\\) is interpreted as a remaining fraction of transmission opportunity, we typically restrict attention to values of \\(z\\) for which \\(f(z)\\ge 0\\), i.e.\n\\[\n0 \\le z \\le \\frac{1}{\\alpha}.\n\\]\nIn plots, we can either fix \\(\\alpha\\) and examine \\(w\\) as a function of \\(z\\), or compare several \\(\\alpha\\) values on the same axes to see how stronger virulence scaling shifts and compresses the fitness curve."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#analytical-solution-maximizing-fitness-w-with-respect-to-host-exploitation",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#analytical-solution-maximizing-fitness-w-with-respect-to-host-exploitation",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "4 Analytical solution maximizing fitness \\(w\\) with respect to host exploitation",
    "text": "4 Analytical solution maximizing fitness \\(w\\) with respect to host exploitation"
  },
  {
    "objectID": "content/models/frank1996model_pathogen-fitness-single-strain.html#pathogen-fitness-as-function-of-virulence",
    "href": "content/models/frank1996model_pathogen-fitness-single-strain.html#pathogen-fitness-as-function-of-virulence",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "",
    "text": "(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa."
  },
  {
    "objectID": "content/models/frank1996model_pathogen-fitness-single-strain.html#linear-decline-in-host-resources-due-to-virulence",
    "href": "content/models/frank1996model_pathogen-fitness-single-strain.html#linear-decline-in-host-resources-due-to-virulence",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "2 Linear decline in host resources due to virulence",
    "text": "2 Linear decline in host resources due to virulence\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\tag{2}\\]"
  },
  {
    "objectID": "content/models/frank1996model_pathogen-fitness-single-strain.html#behavior-under-adaptive-evolution",
    "href": "content/models/frank1996model_pathogen-fitness-single-strain.html#behavior-under-adaptive-evolution",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "3 Behavior under adaptive evolution",
    "text": "3 Behavior under adaptive evolution\nLet \\(z\\) denote a heritable parasite trait (an evolutionary “strategy”) that affects transmission potential and virulence, and let \\(w(z)\\) denote the expected number of new infected hosts produced by a parasite lineage characterized by trait value \\(z\\).\nUnder adaptive evolution, trait values with higher invasion fitness tend to increase in frequency: if a rare mutant with trait \\(z'\\) introduced into a resident population with trait \\(z\\) has \\(w(z' \\mid z) &gt; 1\\) (equivalently, has higher long-run growth than the resident when rare), then the mutant can invade and will tend to rise in frequency.\nIn the special case assumed by the single-strain formulation here—where ecological feedbacks and frequency dependence are ignored so that fitness can be represented as a function of the trait alone, \\(w(z)\\)—an evolutionary equilibrium \\(z^*\\) occurs at an interior stationary point of \\(w\\):\n\\[\n\\frac{d w}{d z}(z^*) = 0,\n\\]\nwith \\(z^*\\) being evolutionarily attracting if small deviations in \\(z\\) are selected back toward \\(z^*\\) (i.e., if the selection gradient changes sign appropriately, and \\(z^*\\) corresponds to a local maximum of \\(w\\) under the stated assumptions).\nFor the linear cost case \\(w(z)=z(1-\\alpha z)\\), the stationary point satisfies\n\\[\n\\frac{d w}{d z} = 1-2\\alpha z = 0\n\\quad\\Rightarrow\\quad\nz^*=\\frac{1}{2\\alpha},\n\\]\nwhich is a local maximum because \\(\\frac{d^2 w}{d z^2}=-2\\alpha&lt;0\\) when \\(\\alpha&gt;0\\)."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "title": "Visualizing the single-strain virulence fitness landscape",
    "section": "3 Visualization of fitness relationship with host exploitation severity",
    "text": "3 Visualization of fitness relationship with host exploitation severity\nTo visualize this model, we can compute \\(w\\) across a range of host exploitation severitys \\(z\\) and plot the resulting fitness curve.\nThe response variable is pathogen fitness \\(w\\), and in the linear-decline model it depends on two parameters:\n\\[\nw(z;\\alpha) = z(1-\\alpha z).\n\\]\nConceptually, we can treat \\(z\\) as a control or tuning variable: it is the parasite strategy we imagine changing. The parameter \\(\\alpha\\) determines how strongly exploitation reduces host resources (how costly virulence is per unit increase in \\(z\\)). For a fixed \\(\\alpha\\), plotting \\(w\\) against \\(z\\) shows a trade-off: increasing \\(z\\) raises transmission potential, but beyond a point the virulence cost dominates and \\(w\\) declines.\nIn Julia, we can generate a grid of \\(z\\) values, evaluate \\(w(z;\\alpha)\\), and plot \\(w\\) versus \\(z\\) for one or several choices of \\(\\alpha\\).\nWe treat \\(z\\) as the horizontal-axis variable (host exploitation strength), and we treat \\(\\alpha\\) as a fixed model parameter that we choose to set to one (or several) representative values. For each chosen \\(\\alpha\\), we compute the corresponding fitness values\n\\[\nw(z;\\alpha) = z(1-\\alpha z)\n\\]\nover a sequence of \\(z\\) values, then plot the resulting curve.\nBecause the term \\((1-\\alpha z)\\) represents the remaining fraction of transmission opportunity, we typically restrict to the biologically meaningful range\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that \\(w(z;\\alpha)\\ge 0\\) on the plotted domain.\n\nusing CairoMakie\n\n# Fitness function\nw(z, α) = z * (1 - α*z)\n\n# Choose one or several α values to compare\nα_values = [0.2, 0.5, 1.0]\n\n# Set up a figure and axis\nfig = Figure()\nax = Axis(\n    fig[1, 1],\n    xlabel = \"host exploitation strength (z)\",\n    ylabel = \"pathogen fitness (w)\",\n    title  = \"Fitness w(z; α) = z(1 - α z)\"\n)\n\n# Plot one curve per α\nfor α in α_values\n    z_values = range(0.0, 1/α; length = 400)\n    w_values = map(z -&gt; w(z, α), z_values)\n    lines!(ax, z_values, w_values, label = \"α = $(α)\")\nend\n\naxislegend(ax)\nfig"
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html",
    "title": "Visualization of fitness relationship with host exploitation severity",
    "section": "",
    "text": "Proficiencies\n\nGenerating a 1D grid of input values with range (or start:step:stop).\nComputing model outputs over a grid with map.\nPlotting a single 2D relationship with an implicit figure/axis (quick exploratory plot).\nCreating an explicit Figure and Axis, and adding multiple curves to the same axis with ...! plotting functions.\nVisualizing a 2-parameter model as a surface by evaluating the model on a 2D grid.\nWe will visualize the single-strain fitness model\n\\[\nw(z;\\alpha) = z(1-\\alpha z),\n\\]\nwhere:\nWhen we plot \\(w\\) versus \\(z\\) for a fixed \\(\\alpha\\), we typically restrict to\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that the transmission-opportunity term \\((1-\\alpha z)\\) stays nonnegative."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "title": "Just enough Julia for scientific informatics and reasoning",
    "section": "",
    "text": "Proficiencies\n\nGenerating a 1D grid of input values with range (or start:step:stop).\nComputing model outputs over a grid with map.\nPlotting a single 2D relationship with an implicit figure/axis (quick exploratory plot).\nCreating an explicit Figure and Axis, and adding multiple curves to the same axis with ...! plotting functions.\nVisualizing a 2-parameter model as a surface by evaluating the model on a 2D grid.\n\n\n\nWe will visualize the single-strain fitness model\n\\[\nw(z;\\alpha) = z(1-\\alpha z),\n\\]\nwhere:\n\n\\(z\\) is host exploitation severity (the model’s adjustable trait variable),\n\\(\\alpha\\) is a fixed scaling parameter that determines how strongly exploitation reduces transmission opportunity,\n\\(w\\) is pathogen fitness (new infected hosts per infected host under the model).\n\nWhen we plot \\(w\\) versus \\(z\\) for a fixed \\(\\alpha\\), we typically restrict to\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that the transmission-opportunity term \\((1-\\alpha z)\\) stays nonnegative."
  },
  {
    "objectID": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#single-alpha-implicit-plot-quick-exploratory",
    "href": "content/practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#single-alpha-implicit-plot-quick-exploratory",
    "title": "Visualization of fitness relationship with host exploitation severity",
    "section": "1 Single \\(\\alpha\\), implicit plot (quick exploratory)",
    "text": "1 Single \\(\\alpha\\), implicit plot (quick exploratory)\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose a single α value\nα = 0.5\n\n# Generate z-values over the biologically meaningful range\nz_vals = range(0.0, 1/α; length = 400)\n\n# Evaluate the model on the grid\nw_vals = map(z -&gt; w(z, α), z_vals)\n\n# Quick plot with implicit Figure/Axis\nlines(z_vals, w_vals)\n\n\n\n\nThis produces one curve showing how fitness changes as host exploitation severity \\(z\\) increases, holding \\(\\alpha\\) fixed.\nMultiple \\(\\alpha\\) values on the same plot (explicit Figure and Axis) using CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose several α values to compare\nα_values = [0.2, 0.5, 1.0]\n\n# Create Figure and Axis explicitly\nfig = Figure()\nax = Axis(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"pathogen fitness (w)\",\n    title  = \"Fitness curves for different α\"\n)\n\n# Add one curve per α onto the same axis\nfor α in α_values\n    z_vals = range(0.0, 1/α; length = 400)\n    w_vals = map(z -&gt; w(z, α), z_vals)\n    lines!(ax, z_vals, w_vals, label = \"α = $(α)\")\nend\n\n# Add a legend\naxislegend(ax)\n\nfig\n\n\n\n\nHere, \\(\\alpha\\) plays the role of a parameter you “sweep” across several values, to see how the \\(w\\)–\\(z\\) relationship changes.\nSurface plot: fitness as a function of \\(z\\) and \\(\\alpha\\)\nTo visualize the full two-parameter relationship \\(w(z;\\alpha)\\), we evaluate \\(w\\) on a 2D grid of \\((z,\\alpha)\\) values and plot a surface.\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Grid of α values (parameter axis)\nα_vals = range(0.2, 1.0; length = 120)\n\n# Grid of z values (trait axis)\n# Use a common z-range for the surface; choose up to 1/max(α) so the full grid is comparable\nz_max = 1 / maximum(α_vals)\nz_vals = range(0.0, z_max; length = 200)\n\n# Evaluate w on the (z, α) grid:\n# W[i, j] = w(z_vals[i], α_vals[j])\nW = [w(z, α) for z in z_vals, α in α_vals]\n\n# Plot as a 3D surface\nfig = Figure()\nax3 = Axis3(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"virulence scaling (α)\",\n    zlabel = \"pathogen fitness (w)\",\n    title  = \"Fitness surface w(z; α)\"\n)\n\nsurface!(ax3, z_vals, α_vals, W)\n\nfig\n\n\n\n\nThis surface makes it visually explicit that \\(w\\) depends on both the trait value (\\(z\\)) and the environment/biology scaling parameter (\\(\\alpha\\)).\n\nExerciseSingle-curve practice (implicit plot)\nSet \\(\\alpha = 0.25\\) and reproduce the single-curve plot.\nIncrease the resolution by changing length = 400 to length = 2000.\nRestrict the plotted domain to \\(0 \\le z \\le \\frac{1}{2\\alpha}\\) and compare the shape to the full range \\(0 \\le z \\le \\frac{1}{\\alpha}\\).\n\n\n\nExerciseMultiple-curve practice (explicit Axis, adding curves)\nPlot curves for \\(\\alpha \\in {0.1, 0.2, 0.4, 0.8}\\) on the same axis.\nAdd a second axis below the first that plots the same curves using scatter! instead of lines!.\nChange axis labels and title so that the plot reads well when exported.\n\n\n\nExerciseSurface practice (2D grid evaluation)\nChange the \\(\\alpha\\) grid to range(0.1, 2.0; length = 200) and regenerate the surface.\nReplace the surface with a heatmap of \\(w\\) over \\((z,\\alpha)\\) using heatmap!(…).\nModify the grid so that, for each \\(\\alpha\\), you only include \\(z \\le 1/\\alpha\\) (the nonnegative-opportunity region) by setting \\(w(z,\\alpha) = NaN\\) whenever \\(z &gt; 1/\\alpha\\), and observe how the plotted region changes."
  }
]